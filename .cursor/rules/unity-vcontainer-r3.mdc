---
description: Unity项目架构规范 - VContainer依赖注入和R3反应式编程
globs: **/*.cs
alwaysApply: false
---

# Unity DI-R3 架构规范

## VContainer 依赖注入

**注册** (在 `ProjectLifetimeScope.cs`):
```csharp
builder.Register<UIManager>(Lifetime.Singleton);
builder.RegisterComponent(gameFlowController);
builder.Register<AudioService>(Lifetime.Singleton).As<IAudioService>();
builder.RegisterInstance(new BgmAudioSourceProvider(bgmSource)).As<IBgmAudioSourceProvider>();
```

**注入**:
```csharp
// MonoBehaviour: 字段注入
[Inject] private UIManager _uiManager;

// 非MonoBehaviour: 构造函数注入
public AudioService(AudioCatalog catalog, IBgmAudioSourceProvider bgmProvider) { }

// ❌ 不要使用 FindObjectOfType 获取已注入的依赖
```

## R3 事件系统

**定义**: 使用 `record` 定义事件
```csharp
public record LanguageConfirmEvent(GameLanguageType ConfirmedLanguage);
```

**发布**: 通过注入的 `EventBus`
```csharp
_eventBus.Publish(new LanguageConfirmEvent(selectedLanguage));
```

**订阅**: 必须绑定生命周期避免泄漏
```csharp
// MonoBehaviour
_eventBus.Receive<LanguageConfirmEvent>()
    .Subscribe(evt => Handle(evt))
    .AddTo(this);

// 非MonoBehaviour
private readonly DisposableBag _disposables = new();
_eventBus.Receive<GameEvent>().Subscribe(Handle).AddTo(_disposables);
```

## UniTask 异步操作

```csharp
// ✅ 使用 UniTask
public async UniTask Init()
{
    await _manager.Init();
}

// ✅ 发射后不管
DoSomethingAsync().Forget();

// ❌ 不要使用 Task（应该用 UniTask）
```

## Addressables 资源管理

**核心模式**: 缓存句柄 + Dispose 释放
```csharp
private readonly Dictionary<string, AsyncOperationHandle<T>> _handles = new();

private async UniTask<T> LoadAsync(string key)
{
    if (_handles.TryGetValue(key, out var cached)) return cached.Result;
    
    var handle = Addressables.LoadAssetAsync<T>(key);
    _handles[key] = handle;
    return await handle.Task.AsUniTask();
}

public void Dispose()
{
    foreach (var handle in _handles.Values)
        if (handle.IsValid()) Addressables.Release(handle);
    _handles.Clear();
}
```

## 状态机

```csharp
private StateMachine<GameState> _stateMachine = new(GameState.Menu);

_stateMachine.Register(GameState.Playing,
    onEnter: () => StartGame(),
    onEnterAsync: async () => await LoadDataAsync());

await _stateMachine.ChangeStateAsync(GameState.Playing);
```

## 命名约定

- 私有字段: `_camelCase` 
- 公共属性/方法: `PascalCase`
- 事件类型: `PascalCase` + `Event` 后缀

## 项目特定

- 生成代码 (`AddressableKeys.cs`, `AudioClipName.cs`) 不要手动编辑
- 使用 Odin Inspector 特性: `[BoxGroup]`, `[LabelText]`, `[ShowInInspector, ReadOnly]`
- 使用基于`record`的强类型事件总线`EventBus`
- 需要在依赖注入式创建`GameObject`时，使用`_resolver.Instantiate()`而不是`UnityEngine.Object.Instantiate()`
